

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tvb.basic.filters.chain &mdash; The Virtual Brain 1.0.4 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.0.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="The Virtual Brain 1.0.4 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">The Virtual Brain 1.0.4 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for tvb.basic.filters.chain</h1><pre>
# -*- coding: utf-8 -*-
#
#
#  TheVirtualBrain-Scientific Package. This package holds all simulators, and 
# analysers necessary to run brain-simulations. You can use it stand alone or
# in conjunction with TheVirtualBrain-Framework Package. See content of the
# documentation-folder for more details. See also http://www.thevirtualbrain.org
#
# (c) 2012-2013, Baycrest Centre for Geriatric Care ("Baycrest")
#
# This program is free software; you can redistribute it and/or modify it under 
# the terms of the GNU General Public License version 2 as published by the Free
# Software Foundation. This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
# License for more details. You should have received a copy of the GNU General 
# Public License along with this program; if not, you can download it here
# http://www.gnu.org/licenses/old-licenses/gpl-2.0
#
#
"""
.. moduleauthor:: Lia Domide &lt;lia.domide@codemart.ro&gt;
.. moduleauthor:: Bogdan Neacsa &lt;bogdan.neacsa@codemart.ro&gt;

The following are the categories that will be available for filters in the UI. 
In case of adding a new category, the first input 'model.DataType.subject' is 
the field from the model that will be used , display represents the
way this field will be visible in the UI to the user, operations mark all the 
possible operations that can be done on that field 
(so far supported are: "==", "!=", "&lt;", "&gt;", "in", "not in"). 
Type represents the type of input that is expected. So far string, date and 
list are supported.

In order to define a default filter, from the adapter interface add::

'conditions': FilterChain(fields= [FilterChain.datatype + ".subject", FilterChain.datatype + ".some_attribute",
                          values= [["John Doe", "JohnDoe1"], "Some Attr Value"], operations= ["in", "=="])
                        
If you want to add a filter to a XML interface::

    &lt;input required="True"&gt;
        &lt;name value="data1"/&gt;
        &lt;label value="First dataset:"/&gt;
        &lt;description value="First set of signals"/&gt;
        &lt;type value="tvb.datatypes.arrays.MappedArray" field="data" default="default_data"&gt;
            &lt;conditions&gt;
                &lt;cond_fields value_list="['datatype_class._nr_dimensions']"/&gt;
                &lt;cond_operations value_list="['==']"/&gt;
                &lt;cond_values value_list="['2']"/&gt;
            &lt;/conditions&gt;
        &lt;/type&gt;
    &lt;/input&gt;
    
"""

import json
import datetime
from tvb.basic.logger.builder import get_logger
from tvb.basic.filters.exceptions import InvalidFilterChainInput, InvalidFilterEntity

KEY_DISPLAY = 'display_name'
KEY_FIELDS = 'fields'
KEY_VALUES = 'values'
KEY_OPERATIONS = 'operations'
KEY_OPERATOR = 'operator'

LOGGER = get_logger(__name__)
       
         
<div class="viewcode-block" id="FilterChain"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.FilterChain">[docs]</a>class FilterChain(object):
    """
    Class used to filter tables displayed in UI, based on few criteria.
    Initialize filter with a list of fields, and corresponding values.
    """
    
    datatype = '$$DATATYPE_INPUT$$'
    algorithm_group = '$$ALGORITHM_GROUP_INPUT$$'
    algorithm_category = '$$ALGORITHM_CATEGORY_INPUT$$'
    operation = '$$OPERATION_INPUT$$'
    
    datatype_replacement = "model.DataType"
    algorithm_group_replacement = "model.AlgorithmGroup"
    algorithm_category_replacement = "model.AlgorithmCategory"
    operation_replacement = "model.Operation"
    
    
    def __init__(self, display_name="", fields=None, values=None, operations=None, operator_between_fields='and'):
        """
        Initialize filter attributes.
        """
        self.display_name = display_name
        self.fields = fields or []
        self.values = values or []
        self.operations = operations or []
        self.operator_between_fields = operator_between_fields
        
        # Is this filter selected or not in the UI
        self.selected = False
        # How many entries will still remain if we apply this filter
        self.passes_count = ''

        
    def __setattr__(self, name, value):
        """
        Overwrite so that the custom keys cannot be overwritten.
        """
        if name in ('datatype', 'algorithm_group', 'algorithm_category', 'operation'):
            raise AttributeError("FilterChain '%s' attribute is used internally and can only be read, not set."%(name,))
        else:
            object.__setattr__(self, name, value)
            
            
    def __add__(self, other):
        """
        Define an addition operation on filters so one can easily do filter1 + filter2
        """
        if other is None:
            return FilterChain(self.display_name, self.fields, self.values, 
                               self.operations, self.operator_between_fields)
        if not isinstance(other, FilterChain):
            raise TypeError("unsupported operand type(s) for +: 'FilterChain' and '%s'"%(type(other).__name__,))
        
        new_display_name = self.display_name + "__" + other.display_name
        new_fields = self.fields[:]
        new_fields.extend(other.fields)
        new_values = self.values[:]
        new_values.extend(other.values)
        operations = self.operations[:]
        operations.extend(other.operations)
        return FilterChain(new_display_name, new_fields, new_values, operations, 'and')
    
    
    def __str__(self):
        return self.__class__.__name__ + "(fields=%s, operations=%s, values=%s, operator_between_fields=%s)"% (
                self.fields, self.operations, self.values, self.operator_between_fields)
    
            
<div class="viewcode-block" id="FilterChain.to_json"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.FilterChain.to_json">[docs]</a>    def to_json(self):
        """
        Return a dictionary representation of the filter, to be used when needed.
        """
        dict_equivalent = {KEY_DISPLAY: self.display_name,
                           KEY_FIELDS: self.fields,
                           KEY_VALUES: self.values,
                           KEY_OPERATIONS: self.operations,
                           KEY_OPERATOR: self.operator_between_fields}
        return json.dumps(dict_equivalent)
    
    </div>
    def __prepare_filter_string(self, filter_string):
        """
        Do all replacements of place-holders with evaluable strings.
        """
        return filter_string.replace(self.datatype, self.datatype_replacement
                             ).replace(self.algorithm_group, self.algorithm_group_replacement
                             ).replace(self.algorithm_category, self.algorithm_category_replacement
                             ).replace(self.operation, self.operation_replacement)
    
    
    @classmethod
<div class="viewcode-block" id="FilterChain.get_filters_for_type"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.FilterChain.get_filters_for_type">[docs]</a>    def get_filters_for_type(cls, data_name):
        """
        Return the list of filters to appear in UI.
        """
        data_class = cls._get_class_instance(data_name)
        if data_class is None or not hasattr(data_class, 'accepted_filters'):
            LOGGER.warning("Invalid Class specification:"+ str(data_name))
            return []
        else:
            return json.dumps(data_class.accepted_filters())
        
        </div>
    @classmethod
    def _get_class_instance(cls, data_name):
        """
        Internal method, to build a DataType class instance, from possible class string-name.
        """
        data_class = data_name
        if isinstance(data_name, (str, unicode)):
            try:
                class_ = str(data_name).split(".")[-1]
                module_ = str(data_name)[:-len(class_)-1].lstrip().rstrip()
                data_class = __import__(module_, globals(), locals(), [class_])
                data_class = eval("data_class."+ class_)
            except Exception, excep:
                LOGGER.error("Expected DataType full class quantifier! Got:" + str(data_name))
                LOGGER.exception(excep)
                data_class = None
        return data_class
    
    
    @classmethod
<div class="viewcode-block" id="FilterChain.from_json"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.FilterChain.from_json">[docs]</a>    def from_json(cls, input_dict):
        """
        From a JSON dictionary create a filter instance.
        """
        if not input_dict or str(input_dict) == 'None':
            return None
        filter_dictionary = json.loads(input_dict)
        return FilterChain(display_name=filter_dictionary[KEY_DISPLAY], fields=filter_dictionary[KEY_FIELDS],
                           values=filter_dictionary[KEY_VALUES], operations=filter_dictionary[KEY_OPERATIONS],
                           operator_between_fields=filter_dictionary[KEY_OPERATOR])
        
</div>
<div class="viewcode-block" id="FilterChain.get_python_filter_equivalent"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.FilterChain.get_python_filter_equivalent">[docs]</a>    def get_python_filter_equivalent(self, datatype_to_check=None, algogroup_to_check=None, 
                                     algocategory_to_check=None, operation_to_check=None):
        """
        Python evaluate of the filter against a current given DataType
        Check a filter instance next to a given input.
        
        @param input_to_check: the dataType to be checked against this filter instance
        
        @return: true if input passed
                 false if input failed
        """
        passed_test = True
        ## set to current method input parameters, as these strings will be use in eval
        self.datatype_replacement = 'datatype_to_check'
        self.algorithm_group_replacement = 'algogroup_to_check'
        self.algorithm_category_replacement = 'algocategory_to_check'
        self.operation_replacement = 'operation_to_check'
        
        for i in range(len(self.fields)):
            #### Any filter validations checks start here #####
            
            if self.operations[i] in  ('in', 'not in'):
                try:
                    iter(self.values[i])
                except TypeError:
                    raise InvalidFilterEntity("Invalid filter! %s. not applicable for value %s"%(self.operations[i], 
                                                                                                 self.values[i]))
                
            #### Any filter validations checks end here #####
            my_filter = self.__prepare_filter_string(self.fields[i]) + ' ' + self.operations[i] +" "
            if type(self.values[i]) in (str, unicode):
                prepared_value = self.__prepare_filter_string(self.values[i])
                if prepared_value != self.values[i]:
                    ## It's not just some string, but a FilterChain expression.
                    my_filter = my_filter + str(self.values[i])
                else:
                    ## It's just a string, need to add quoates so eval won't search for a variable with that name.
                    my_filter = my_filter + str('"' + self.values[i] + '"')
            else:
                ## Try to replace here as well since we might have a list of place-holders.
                prepared_value = self.__prepare_filter_string(str(self.values[i]))
                my_filter = my_filter + prepared_value
                
            try:
                my_filter = eval(my_filter)
            except AttributeError:
                raise InvalidFilterChainInput("On %s filtered attribute %s is missing."%(datatype_to_check, 
                                                            self.fields[i].replace('input_to_check.', '')))
            passed_test = eval('passed_test ' + self.operator_between_fields + ' my_filter')
        return passed_test
    
    </div>
<div class="viewcode-block" id="FilterChain.get_sql_filter_equivalent"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.FilterChain.get_sql_filter_equivalent">[docs]</a>    def get_sql_filter_equivalent(self, datatype_to_check="model.DataType", operation_to_check="model.Operation", 
                            algogroup_to_check="model.AlgorithmGroup", algocategory_to_check="model.AlgorithmCategory"):
        """
        Returns the computed SQL string from the given filter.
        The method may return None if the filter is None or the
        fields of the filter are not set.
        
        The input to this method should be a string representing the name under which 
        the variable you want to be filtered was binded in the callers namespace.
        e.g.  
        def foo(var_to_filter, filter_entity):
            filter_entity.get_sql_filter_equivalent('var_to_filter')
        """
        
        if self.fields is None or len(self.fields) == 0:
            return None
        
        self.datatype_replacement = datatype_to_check
        self.algorithm_group_replacement = algogroup_to_check
        self.algorithm_category_replacement = algocategory_to_check
        self.operation_replacement = operation_to_check
        
        filter_str = self.operator_between_fields + "_("
        for i, field in enumerate(self.fields):
            if i &gt; 0 :
                filter_str += ","
            field = self.__prepare_filter_string(field)
            filter_str = filter_str + self.__get_sql_filter_equivalent(field, self.operations[i], self.values[i])
        filter_str += ")"
        return filter_str

</div>
    def __get_sql_filter_equivalent(self, field, operation, value):
        """
        For a field, value and operation get the sql-alchemy specific syntax.
        """
        result = ""
        if operation in ("not in", "in"):
            prepared_value = self.__prepare_filter_string(str(value))
            if type(value) in (str, unicode):
                if prepared_value == value:
                    ## It was just a regular string, need to add quotes so it's not evaluated to a variable
                    prepared_value = '"' + prepared_value + '"'
                prepared_value = '[' + prepared_value + ']'
            if operation == "not in":
                result = result + "not_(" + field + ".in_(" + prepared_value + "))"
            elif operation == "in":
                result = result + field + ".in_(" + prepared_value + ")"
        elif operation == "like":
            result = result + field + ".ilike('"
            filter_value = self.__prepare_filter_string(str(value).lstrip().rstrip())
            if '%' not in filter_value:
                filter_value = '%' + filter_value + '%'
            result = result + filter_value + "')"
        else:
            result = result + field
            result = result + operation
            prepared_value = self.__prepare_filter_string(str(value))
            if type(value) in (str, unicode, datetime.datetime):
                if prepared_value == str(value):
                    ## It was just a regular string, need to add quotes so it's not evaluated to a variable
                    prepared_value = '"' + prepared_value + '"'
            result = result + prepared_value
        return result
        
        
<div class="viewcode-block" id="FilterChain.add_condition"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.FilterChain.add_condition">[docs]</a>    def add_condition(self, field_name, operation_string, value):
        """
        Append to the list of conditions.
        """
        self.fields.append(field_name)
        self.operations.append(operation_string)
        self.values.append(value)
        

</div></div>
<div class="viewcode-block" id="UIFilter"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.UIFilter">[docs]</a>class UIFilter():
    """
    Helper class for the UI filters.
    """  
          
    def __init__(self, linked_elem_name, linked_elem_field, linked_elem_parent_name, linked_elem_parent_option):
        self.linked_elem_name = linked_elem_name
        self.linked_elem_field = linked_elem_field
        self.linked_elem_parent_name = linked_elem_parent_name
        self.linked_elem_parent_option = linked_elem_parent_option

<div class="viewcode-block" id="UIFilter.to_dict"><a class="viewcode-back" href="../../../../tvb.basic.filters.html#tvb.basic.filters.chain.UIFilter.to_dict">[docs]</a>    def to_dict(self):
        """
        Prepare for passing in UI
        """
        return {'linked_elem_name' : self.linked_elem_name,
                'linked_elem_field' : self.linked_elem_field,
                'linked_elem_parent_name' : self.linked_elem_parent_name,
                'linked_elem_parent_option' : self.linked_elem_parent_option}
    
    </div></div>
</pre>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">The Virtual Brain 1.0.4 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>