<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tvb.simulator.simulator &mdash; The Virtual Brain 1.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="top" title="The Virtual Brain 1.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">The Virtual Brain 1.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for tvb.simulator.simulator</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#  TheVirtualBrain-Scientific Package. This package holds all simulators, and </span>
<span class="c"># analysers necessary to run brain-simulations. You can use it stand alone or</span>
<span class="c"># in conjunction with TheVirtualBrain-Framework Package. See content of the</span>
<span class="c"># documentation-folder for more details. See also http://www.thevirtualbrain.org</span>
<span class="c">#</span>
<span class="c"># (c) 2012-2013, Baycrest Centre for Geriatric Care (&quot;Baycrest&quot;)</span>
<span class="c">#</span>
<span class="c"># This program is free software; you can redistribute it and/or modify it under </span>
<span class="c"># the terms of the GNU General Public License version 2 as published by the Free</span>
<span class="c"># Software Foundation. This program is distributed in the hope that it will be</span>
<span class="c"># useful, but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public</span>
<span class="c"># License for more details. You should have received a copy of the GNU General </span>
<span class="c"># Public License along with this program; if not, you can download it here</span>
<span class="c"># http://www.gnu.org/licenses/old-licenses/gpl-2.0</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#   CITATION:</span>
<span class="c"># When using The Virtual Brain for scientific publications, please cite it as follows:</span>
<span class="c">#</span>
<span class="c">#   Paula Sanz Leon, Stuart A. Knock, M. Marmaduke Woodman, Lia Domide,</span>
<span class="c">#   Jochen Mersmann, Anthony R. McIntosh, Viktor Jirsa (2013)</span>
<span class="c">#       The Virtual Brain: a simulator of primate brain network dynamics.</span>
<span class="c">#   Frontiers in Neuroinformatics (7:10. doi: 10.3389/fninf.2013.00010)</span>
<span class="c">#</span>
<span class="c">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is the main module of the simulator. It defines the Simulator class which</span>
<span class="sd">brings together all the structural and dynamic components necessary to define a</span>
<span class="sd">simulation and the method for running the simulation.</span>

<span class="sd">.. moduleauthor:: Stuart A. Knock &lt;Stuart@tvb.invalid&gt;</span>
<span class="sd">.. moduleauthor:: Marmaduke Woodman &lt;mw@eml.cc&gt;</span>
<span class="sd">.. moduleauthor:: Paula Sanz Leon &lt;Paula@tvb.invalid&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># From standard python libraries</span>

<span class="c"># Third party python libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="kn">as</span> <span class="nn">sparse</span>

<span class="c"># From &quot;The Virtual Brain&quot;</span>
<span class="kn">from</span> <span class="nn">tvb.basic.config.settings</span> <span class="kn">import</span> <span class="n">TVBSettings</span>
<span class="kn">import</span> <span class="nn">tvb.basic.traits.core</span> <span class="kn">as</span> <span class="nn">core</span>
<span class="kn">import</span> <span class="nn">tvb.basic.traits.types_basic</span> <span class="kn">as</span> <span class="nn">basic</span>
<span class="kn">from</span> <span class="nn">tvb.basic.filters.chain</span> <span class="kn">import</span> <span class="n">UIFilter</span><span class="p">,</span> <span class="n">FilterChain</span>

<span class="kn">import</span> <span class="nn">tvb.simulator.models</span> <span class="kn">as</span> <span class="nn">models_module</span>
<span class="kn">import</span> <span class="nn">tvb.simulator.integrators</span> <span class="kn">as</span> <span class="nn">integrators_module</span>
<span class="kn">import</span> <span class="nn">tvb.simulator.monitors</span> <span class="kn">as</span> <span class="nn">monitors_module</span>
<span class="kn">import</span> <span class="nn">tvb.simulator.coupling</span> <span class="kn">as</span> <span class="nn">coupling_module</span>

<span class="kn">import</span> <span class="nn">tvb.datatypes.arrays</span> <span class="kn">as</span> <span class="nn">arrays_dtype</span>
<span class="kn">import</span> <span class="nn">tvb.datatypes.surfaces</span> <span class="kn">as</span> <span class="nn">surfaces_dtype</span>
<span class="kn">import</span> <span class="nn">tvb.datatypes.connectivity</span> <span class="kn">as</span> <span class="nn">connectivity_dtype</span>
<span class="c">#import tvb.datatypes.coupling as coupling_dtype</span>
<span class="kn">import</span> <span class="nn">tvb.datatypes.patterns</span> <span class="kn">as</span> <span class="nn">patterns_dtype</span>

<span class="kn">from</span> <span class="nn">tvb.simulator.common</span> <span class="kn">import</span> <span class="n">psutil</span><span class="p">,</span> <span class="n">get_logger</span>
<span class="n">LOG</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>


<span class="c">#from tvb.simulator.common import iround</span>

<div class="viewcode-block" id="Simulator"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator">[docs]</a><span class="k">class</span> <span class="nc">Simulator</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Simulator class coordinates classes from all other modules in the</span>
<span class="sd">    simulator package in order to perform simulations. </span>

<span class="sd">    In general, it is necessary to initialiaze a simulator with the desired</span>
<span class="sd">    components and then call the simulator in a loop to obtain simulation</span>
<span class="sd">    data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; sim = Simulator(...)</span>
<span class="sd">    &gt;&gt;&gt; for output in sim(simulation_length=1000):</span>
<span class="sd">            ...</span>
<span class="sd">    </span>
<span class="sd">    Please refer to the user guide and the demos for more detail.</span>


<span class="sd">    .. #Currently there seems to be a clash betwen traits and autodoc, autodoc</span>
<span class="sd">    .. #can&#39;t find the methods of the class, the class specific names below get</span>
<span class="sd">    .. #us around this...</span>
<span class="sd">    .. automethod:: Simulator.__init__</span>
<span class="sd">    .. automethod:: Simulator.configure</span>
<span class="sd">    .. automethod:: Simulator.__call__</span>
<span class="sd">    .. automethod:: Simulator.configure_history</span>
<span class="sd">    .. automethod:: Simulator.configure_integrator_noise</span>
<span class="sd">    .. automethod:: Simulator.memory_requirement</span>
<span class="sd">    .. automethod:: Simulator.runtime</span>
<span class="sd">    .. automethod:: Simulator.storage_requirement</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">connectivity</span> <span class="o">=</span> <span class="n">connectivity_dtype</span><span class="o">.</span><span class="n">Connectivity</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Long-range connectivity&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
        <span class="n">filters_ui</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIFilter</span><span class="p">(</span><span class="n">linked_elem_name</span><span class="o">=</span><span class="s">&quot;projection_matrix_data&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_field</span><span class="o">=</span><span class="n">FilterChain</span><span class="o">.</span><span class="n">datatype</span> <span class="o">+</span> <span class="s">&quot;._sources&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_parent_name</span><span class="o">=</span><span class="s">&quot;monitors&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_parent_option</span><span class="o">=</span><span class="s">&quot;EEG&quot;</span><span class="p">),</span>
                      <span class="n">UIFilter</span><span class="p">(</span><span class="n">linked_elem_name</span><span class="o">=</span><span class="s">&quot;region_mapping_data&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_field</span><span class="o">=</span><span class="n">FilterChain</span><span class="o">.</span><span class="n">datatype</span> <span class="o">+</span> <span class="s">&quot;._connectivity&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_parent_name</span><span class="o">=</span><span class="s">&quot;surface&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_parent_option</span><span class="o">=</span><span class="bp">None</span><span class="p">)],</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;A tvb.datatypes.Connectivity object which contains the </span>
<span class="s">        structural long-range connectivity data (i.e., white-matter tracts). In</span>
<span class="s">        combination with the ``Long-range coupling function`` it defines the inter-regional</span>
<span class="s">        connections. These couplings undergo a time delay via signal propagation </span>
<span class="s">        with a propagation speed of ``Conduction Speed``&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">conduction_speed</span> <span class="o">=</span> <span class="n">basic</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Conduction Speed&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
        <span class="nb">range</span> <span class="o">=</span> <span class="n">basic</span><span class="o">.</span><span class="n">Range</span><span class="p">(</span><span class="n">lo</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="mf">100.0</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">),</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Conduction speed for ``Long-range connectivity`` (mm/ms)&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">coupling</span> <span class="o">=</span> <span class="n">coupling_module</span><span class="o">.</span><span class="n">Coupling</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Long-range coupling function&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">coupling_module</span><span class="o">.</span><span class="n">Linear</span><span class="p">(),</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;The coupling function is applied to the activity propagated</span>
<span class="s">        between regions by the ``Long-range connectivity`` before it enters the local</span>
<span class="s">        dynamic equations of the Model. Its primary purpose is to &#39;rescale&#39; the</span>
<span class="s">        incoming activity to a level appropriate to Model.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">surface</span> <span class="o">=</span> <span class="n">surfaces_dtype</span><span class="o">.</span><span class="n">Cortex</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Cortical surface&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
        <span class="n">filters_ui</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIFilter</span><span class="p">(</span><span class="n">linked_elem_name</span><span class="o">=</span><span class="s">&quot;projection_matrix_data&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_field</span><span class="o">=</span><span class="n">FilterChain</span><span class="o">.</span><span class="n">datatype</span> <span class="o">+</span> <span class="s">&quot;._sources&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_parent_name</span><span class="o">=</span><span class="s">&quot;monitors&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_parent_option</span><span class="o">=</span><span class="s">&quot;EEG&quot;</span><span class="p">),</span>
                      <span class="n">UIFilter</span><span class="p">(</span><span class="n">linked_elem_name</span><span class="o">=</span><span class="s">&quot;local_connectivity&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_field</span><span class="o">=</span><span class="n">FilterChain</span><span class="o">.</span><span class="n">datatype</span> <span class="o">+</span> <span class="s">&quot;._surface&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_parent_name</span><span class="o">=</span><span class="s">&quot;surface&quot;</span><span class="p">,</span> 
                               <span class="n">linked_elem_parent_option</span><span class="o">=</span><span class="bp">None</span><span class="p">)],</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;By default, a tvb.datatypes.Cortex object which represents the </span>
<span class="s">        cortical surface defined by points in the 3D physical space and their </span>
<span class="s">        neighborhood relationship. In the current TVB version, when setting up a </span>
<span class="s">        surface-based simulation, the option to configure the spatial spread of </span>
<span class="s">        the ``Local Connectivity`` is available.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">stimulus</span> <span class="o">=</span> <span class="n">patterns_dtype</span><span class="o">.</span><span class="n">SpatioTemporalPattern</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Spatiotemporal stimulus&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;A ``Spatiotemporal stimulus`` can be defined at the region or surface level.</span>
<span class="s">        It&#39;s composed of spatial and temporal components. For region defined stimuli</span>
<span class="s">        the spatial component is just the strength with which the temporal</span>
<span class="s">        component is applied to each region. For surface defined stimuli,  a</span>
<span class="s">        (spatial) function, with finite-support, is used to define the strength </span>
<span class="s">        of the stimuli on the surface centred around one or more focal points. </span>
<span class="s">        In the current version of TVB, stimuli are applied to the first state </span>
<span class="s">        variable of the ``Local dynamic model``.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">models_module</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Local dynamic model&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">models_module</span><span class="o">.</span><span class="n">Generic2dOscillator</span><span class="p">,</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;A tvb.simulator.Model object which describe the local dynamic</span>
<span class="s">        equations, their parameters, and, to some extent, where connectivity</span>
<span class="s">        (local and long-range) enters and which state-variables the Monitors</span>
<span class="s">        monitor. By default the &#39;Generic2dOscillator&#39; model is used. Read the </span>
<span class="s">        Scientific documentation to learn more about this model.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">integrator</span> <span class="o">=</span> <span class="n">integrators_module</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Integration scheme&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">integrators_module</span><span class="o">.</span><span class="n">HeunDeterministic</span><span class="p">,</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;A tvb.simulator.Integrator object which is</span>
<span class="s">            an integration scheme with supporting attributes such as </span>
<span class="s">            integration step size and noise specification for stochastic </span>
<span class="s">            methods. It is used to compute the time courses of the model state </span>
<span class="s">            variables.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">arrays_dtype</span><span class="o">.</span><span class="n">FloatArray</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Initial Conditions&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="c">#Hidden until UI support exists.</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Initial conditions from which the simulation will begin. By </span>
<span class="s">        default, random initial conditions are provided. Needs to be the same shape</span>
<span class="s">        as simulator &#39;history&#39;, ie, initial history function which defines the </span>
<span class="s">        minimal initial state of the network with time delays before time t=0. </span>
<span class="s">        If the number of time points in the provided array is insufficient the </span>
<span class="s">        array will be padded with random values based on the &#39;state_variables_range&#39;</span>
<span class="s">        attribute.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">monitors</span> <span class="o">=</span> <span class="n">monitors_module</span><span class="o">.</span><span class="n">Monitor</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Monitor(s)&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">monitors_module</span><span class="o">.</span><span class="n">TemporalAverage</span><span class="p">,</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">select_multiple</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;A tvb.simulator.Monitor or a list of tvb.simulator.Monitor</span>
<span class="s">        objects that &#39;know&#39; how to record relevant data from the simulation. Two</span>
<span class="s">        main types exist: 1) simple, spatial and temporal, reductions (subsets</span>
<span class="s">        or averages); 2) physiological measurements, such as EEG, MEG and fMRI.</span>
<span class="s">        By default the Model&#39;s specified variables_of_interest are returned,</span>
<span class="s">        temporally downsampled from the raw integration rate to a sample rate of</span>
<span class="s">        1024Hz.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">simulation_length</span> <span class="o">=</span> <span class="n">basic</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">&quot;Simulation Length (ms)&quot;</span><span class="p">,</span>
        <span class="n">default</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="p">,</span><span class="c">#ie 1 second</span>
        <span class="n">required</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;The length of a simulation in milliseconds (ms).&quot;&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Simulator.__init__"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the base class&#39; mechanisms to initialise the traited attributes </span>
<span class="sd">        declared above, overriding defaults with any provided keywords. Then</span>
<span class="sd">        declare any non-traited attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Simulator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> 
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calls</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_step</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_requirement_guess</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_requirement_census</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage_requirement</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_runtime</span> <span class="o">=</span> <span class="bp">None</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Simulator(**kwargs)&quot;</span>

<div class="viewcode-block" id="Simulator.configure"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator.configure">[docs]</a>    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        THe first step of configuration is to run the configure methods of all</span>
<span class="sd">        the Simulator&#39;s components, ie its traited attributes.</span>

<span class="sd">        Configuration of a Simulator primarily consists of calculating the</span>
<span class="sd">        attributes, etc, which depend on the combinations of the Simulator&#39;s</span>
<span class="sd">        traited attributes (keyword args).</span>

<span class="sd">        Converts delays from physical time units into integration steps</span>
<span class="sd">        and updates attributes that depend on combinations of the 6 inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c">##--- Perform independent configure of traited attribute components --##</span>
        <span class="c">#TODO: Temporary hack, until actual speed attribute is properly accessible from UI.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conduction_speed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Setting connectivity.speed with conduction_speed provided to simulator.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">conduction_speed</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>

        <span class="c"># monitors needs to be a list or tuple, even if there is only one...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">monitors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">]</span>

        <span class="c"># Configure monitors</span>
        <span class="k">for</span> <span class="n">monitor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">:</span>
            <span class="n">monitor</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>

        <span class="c">##------------- Now the the interdependant configuration -------------##</span>

        <span class="c">#&quot;Nodes&quot; refers to either regions or vertices + non-cortical regions.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">number_of_regions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#try:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">region_mapping</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c">#except AttributeError:</span>
            <span class="c">#    msg = &quot;%s: Surface needs region mapping defined... &quot;</span>
            <span class="c">#    LOG.error(msg % (repr(self)))</span>

        <span class="c">#Make sure spatialised model parameters have the right shape (number_of_nodes, 1)</span>
        <span class="n">excluded_checks</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;state_variable_range&quot;</span><span class="p">,</span> <span class="s">&quot;variables_of_interest&quot;</span><span class="p">,</span> <span class="s">&quot;noise&quot;</span><span class="p">,</span> <span class="s">&quot;psi_table&quot;</span><span class="p">,</span> <span class="s">&quot;nerf_table&quot;</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">trait</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">excluded_checks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="n">params</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="c">#If it&#39;s a surface sim and model parameters were provided at the region level</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span><span class="c">#TODO: Once traits are working properly again, the evals and execs here shouldn&#39;t be necessary...</span>
                <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&quot;self.model.&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s">&quot;.size&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">number_of_regions</span><span class="p">:</span>
                    <span class="k">exec</span><span class="p">(</span><span class="s">&quot;self.model.&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s">&quot; = self.model.&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s">&quot;[self.surface.region_mapping].reshape((-1, 1))&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&quot;self.model.&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s">&quot;.size&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">:</span>
                <span class="k">exec</span><span class="p">(</span><span class="s">&quot;self.model.&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s">&quot; = self.model.&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s">&quot;.reshape((-1, 1))&quot;</span><span class="p">)</span>

        <span class="c"># Estimate of memory usage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guesstimate_memory_requirement</span><span class="p">()</span>

        <span class="c">#Configure spatial component of any stimuli</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure_stimuli</span><span class="p">()</span>

        <span class="c">#Set delays, provided in physical units, in integration steps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">set_idelays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">idelays</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;horizon is </span><span class="si">%d</span><span class="s"> steps&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">)</span>

        <span class="c"># workspace -- minimal state of network with delays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: History shape will be: </span><span class="si">%s</span><span class="s">&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span><span class="p">)))</span>

        <span class="c">#Reshape integrator.noise.nsig, if neccessary.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="p">,</span> <span class="n">integrators_module</span><span class="o">.</span><span class="n">IntegratorStochastic</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">configure_integrator_noise</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">configure_history</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span><span class="p">)</span>

        <span class="c">#Configure Monitors to work with selected Model, etc...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure_monitors</span><span class="p">()</span>

        <span class="c">#Estimate of memory usage. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_census_memory_requirement</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Simulator.__call__"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation_length</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When a Simulator is called it returns an iterator.</span>

<span class="sd">        kwargs:</span>

<span class="sd">        ``simulation_length``:</span>
<span class="sd">           total time of simulation</span>

<span class="sd">        ``random_state``: </span>
<span class="sd">           a state for the NumPy random number generator, saved from a previous </span>
<span class="sd">           call to permit consistent continuation of a simulation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#The number of times this Simulator has been called.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calls</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c">#Update the simulator objects simulation_length attribute,</span>
        <span class="k">if</span> <span class="n">simulation_length</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">simulation_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simulation_length</span> <span class="o">=</span> <span class="n">simulation_length</span>

        <span class="c">#Estimate run time and storage requirements, with logging.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guesstimate_runtime</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_storage_requirement</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="p">,</span> <span class="n">integrators_module</span><span class="o">.</span><span class="n">IntegratorStochastic</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">random_stream</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
                <span class="c">#msg = &quot;%s: random_state supplied. Seed is: %s&quot;</span>
                <span class="c">#LOG.info(msg % str(self, self.integrator.noise.random_stream.get_state()[1][0]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: random_state supplied for non-stochastic integration&quot;</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c">#Determine the number of integration steps required to produce  </span>
        <span class="c">#data of simulation_length</span>
        <span class="n">int_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">simulation_length</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: gonna do </span><span class="si">%d</span><span class="s"> integration steps&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">int_steps</span><span class="p">))</span>

        <span class="c"># locals for cleaner code.</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
        <span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span>
        <span class="n">dfun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dfun</span>
        <span class="n">coupling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling</span>
        <span class="n">scheme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">scheme</span>
        <span class="n">npsum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span>
        <span class="n">npdot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span>
        <span class="n">ncvar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cvar</span><span class="p">)</span>
        <span class="n">number_of_regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">number_of_regions</span>
        <span class="n">nsn</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_of_regions</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">number_of_regions</span><span class="p">)</span>
        <span class="c">#import pdb; pdb.set_trace()</span>

        <span class="c">#Create cvar index array of shape ...</span>
        <span class="n">cvar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nsn</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncvar</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ncvar</span><span class="p">):</span>
            <span class="n">cvar</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cvar</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">cvar</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: cvar shape is: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">cvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: cvars are : </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cvar</span><span class="p">))))</span>

        <span class="c">#reshaped connectivity.idelays for ...</span>
        <span class="n">idelays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">idelays</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nsn</span><span class="p">)</span>
        <span class="n">idelays</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">idelays</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncvar</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c">#print idelays</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: idelays shape is: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">idelays</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="c">#reshaped connectivity.weights for ...</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nsn</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncvar</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span><span class="p">))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: weights shape is: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="c">#Create node index array of shape ...</span>
        <span class="n">node_ids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">number_of_regions</span><span class="p">)[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                              <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">number_of_regions</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nsn</span><span class="p">)</span>
        <span class="n">node_ids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">node_ids</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncvar</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: node_ids shape is: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="c">#import pdb; pdb.set_trace()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">local_coupling</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">region_average</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">region_average</span>
            <span class="n">region_history</span> <span class="o">=</span> <span class="n">npdot</span><span class="p">(</span><span class="n">region_average</span><span class="p">,</span> <span class="n">history</span><span class="p">)</span> 
            <span class="n">region_history</span> <span class="o">=</span> <span class="n">region_history</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">coupling_strength</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">local_coupling</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">coupling_strength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">local_connectivity</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">coupling_strength</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">:</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">vec_cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,))</span>
                <span class="n">vec_cs</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">number_of_vertices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">coupling_strength</span>
                <span class="n">sp_cs</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="n">vec_cs</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">ind</span><span class="p">)),</span>
                                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">))</span>
                <span class="n">local_coupling</span> <span class="o">=</span> <span class="n">sp_cs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">local_connectivity</span><span class="o">.</span><span class="n">matrix</span>

            <span class="c">#local_coupling = local_coupling.tocsr()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stimulus</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span> <span class="c">#TODO: Consider changing to absolute time...</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">simulation_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span><span class="o">.</span><span class="n">configure_time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="n">stimulus</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: stimulus shape is: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">stimulus</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="c"># initial state, history[timepoint[0], state_variables, nodes, modes]</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">history</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_step</span> <span class="o">%</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: state shape is: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="c">#print state[0, ]</span>
        
        <span class="c"># record initial state </span>
        <span class="c">#output = [monitor.record(horizon - self.current_step - 1 , state) for monitor in self.monitors]</span>
        <span class="c">#if any(outputi is not None for outputi in output):</span>
        <span class="c">#    yield output</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_step</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_step</span><span class="o">+</span><span class="n">int_steps</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">delayed_state</span> <span class="o">=</span> <span class="n">history</span><span class="p">[(</span><span class="n">step</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">idelays</span><span class="p">)</span> <span class="o">%</span> <span class="n">horizon</span><span class="p">,</span> <span class="n">cvar</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c">#coupling._set_pattern(npsum(delayed_state * weights, axis=0))</span>
                <span class="c">#node_coupling = coupling.pattern</span>
                <span class="n">node_coupling</span> <span class="o">=</span> <span class="n">coupling</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cvar</span><span class="p">],</span> <span class="n">delayed_state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">delayed_state</span> <span class="o">=</span> <span class="n">region_history</span><span class="p">[(</span><span class="n">step</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">idelays</span><span class="p">)</span> <span class="o">%</span> <span class="n">horizon</span><span class="p">,</span> <span class="n">cvar</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c">#coupling._set_pattern(npsum(delayed_state * weights, axis=0))</span>
                <span class="c">#region_coupling = coupling.pattern</span>
                <span class="n">region_coupling</span> <span class="o">=</span> <span class="n">coupling</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cvar</span><span class="p">],</span> <span class="n">delayed_state</span><span class="p">)</span>
                <span class="n">node_coupling</span> <span class="o">=</span> <span class="n">npdot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">vertex_mapping</span><span class="p">,</span> <span class="n">region_coupling</span><span class="p">)</span>
                <span class="n">node_coupling</span> <span class="o">=</span> <span class="n">node_coupling</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="c">#import pdb; pdb.set_trace()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stimulus</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cvar</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span><span class="p">(</span><span class="n">step</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_step</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="c">#import pdb; pdb.set_trace()</span>

            <span class="c">#import pdb; pdb.set_trace()</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">scheme</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dfun</span><span class="p">,</span> <span class="n">node_coupling</span><span class="p">,</span> <span class="n">local_coupling</span><span class="p">,</span> <span class="n">stimulus</span><span class="p">)</span>
            <span class="n">history</span><span class="p">[</span><span class="n">step</span> <span class="o">%</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">state</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">region_history</span><span class="p">[</span><span class="n">step</span> <span class="o">%</span> <span class="n">horizon</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">npdot</span><span class="p">(</span><span class="n">region_average</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="c"># monitor.things e.g. raw, average, eeg, meg, fmri...</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">monitor</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="k">for</span> <span class="n">monitor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">outputi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">outputi</span> <span class="ow">in</span> <span class="n">output</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">output</span>

            <span class="c">#TODO: Need to be able to pause and resume a running simulation.</span>

        <span class="c">#import pdb; pdb.set_trace()</span>
        <span class="c">#Update to support continuation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_step</span> <span class="o">+</span> <span class="n">int_steps</span> <span class="o">-</span> <span class="mi">1</span> <span class="c">#TODO: Don&#39;t think this -1 should be here, check...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span><span class="c">#</span>

</div>
<div class="viewcode-block" id="Simulator.configure_history"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator.configure_history">[docs]</a>    <span class="k">def</span> <span class="nf">configure_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_conditions</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set initial conditions for the simulation using either the provided </span>
<span class="sd">        initial_conditions or, if none are provided, the model&#39;s initial() </span>
<span class="sd">        method. This method is called durin the Simulator&#39;s __init__(). </span>

<span class="sd">        Any initial_conditions that are provided as an argument are expected </span>
<span class="sd">        to have dimensions 1, 2, and 3 with shapse corresponding to the number</span>
<span class="sd">        of state_variables, nodes and modes, respectively. If the provided </span>
<span class="sd">        inital_conditions are shorter in time (dim=0) than the required history</span>
<span class="sd">        the model&#39;s initial() method is called to make up the difference.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span>
        <span class="k">if</span> <span class="n">initial_conditions</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: Setting default history using model&#39;s initial() method.&quot;</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># history should be [timepoints, state_variables, nodes, modes]</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Received initial conditions as arg.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">ic_shape</span> <span class="o">=</span> <span class="n">initial_conditions</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">ic_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: bad initial_conditions[1:] shape </span><span class="si">%s</span><span class="s">, should be </span><span class="si">%s</span><span class="s">&quot;</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">ic_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> 
                                 <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ic_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: Using last </span><span class="si">%s</span><span class="s"> time-steps for history.&quot;</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">))</span>
                    <span class="n">history</span> <span class="o">=</span> <span class="n">initial_conditions</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: initial_conditions shorter than required.&quot;</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: Using model&#39;s initial() method for difference.&quot;</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                    <span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span><span class="p">)</span>
                    <span class="n">csmh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_step</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span>
                    <span class="n">history</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="o">-</span><span class="n">csmh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">history</span><span class="p">[:</span><span class="n">ic_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">initial_conditions</span>
                    <span class="n">history</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="n">csmh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_step</span> <span class="o">+=</span> <span class="n">ic_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: history shape is: </span><span class="si">%s</span><span class="s">&quot;</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">history</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">history</span>
</div>
<div class="viewcode-block" id="Simulator.configure_integrator_noise"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator.configure_integrator_noise">[docs]</a>    <span class="k">def</span> <span class="nf">configure_integrator_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This enables having noise to be state variable specific and/or to enter </span>
<span class="sd">        only via specific brain structures, for example it we only want to </span>
<span class="sd">        consider noise as an external input entering the brain via appropriate</span>
<span class="sd">        thalamic nuclei.</span>

<span class="sd">        Support 3 possible shapes:</span>
<span class="sd">            1) number_of_nodes;</span>

<span class="sd">            2) number_of_state_variables; and </span>

<span class="sd">            3) (number_of_state_variables, number_of_nodes).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span>        

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">ntau</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">configure_coloured</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">configure_white</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">good_history_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">nsig</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">number_of_regions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">nsig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">nsig</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">region_mapping</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">nsig</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">number_of_regions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">nsig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">nsig</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">region_mapping</span><span class="p">]</span>

        <span class="n">good_nsig_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span><span class="p">)</span>
        <span class="n">nsig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">nsig</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Simulator.integrator.noise.nsig shape: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">nsig</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nsig</span><span class="o">.</span><span class="n">shape</span> <span class="ow">in</span> <span class="p">(</span><span class="n">good_nsig_shape</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)):</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">nsig</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span><span class="p">,</span> <span class="p">):</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="n">nsig</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">nsig</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span> <span class="p">):</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="n">nsig</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">nsig</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">):</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="n">nsig</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Bad Simulator.integrator.noise.nsig shape: </span><span class="si">%s</span><span class="s">&quot;</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">nsig</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Simulator.integrator.noise.nsig shape: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">nsig</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">nsig</span> <span class="o">=</span> <span class="n">nsig</span>
        <span class="c">#LOG.debug(&quot;Simulator.integrator.noise.random_stream seed is: %s&quot; % str(self.integrator.noise.random_stream.trait.value.get_state()[1][0]))</span>

</div>
    <span class="k">def</span> <span class="nf">configure_monitors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Configure the requested Monitors for this Simulator &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">monitors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">]</span>

        <span class="c"># Configure monitors </span>
        <span class="k">for</span> <span class="n">monitor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">:</span>
            <span class="n">monitor</span><span class="o">.</span><span class="n">config_for_sim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">configure_stimuli</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Configure the defined Stimuli for this Simulator &quot;&quot;&quot;</span>
        <span class="c">#Configure spatial component of any stimuli</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span><span class="o">.</span><span class="n">configure_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">region_mapping</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stimulus</span><span class="o">.</span><span class="n">configure_space</span><span class="p">()</span>
<span class="c">#TODO: The below was moved to the specific Stimuli datatypes, should be removed from here once we&#39;re sure all is right in the world...</span>
<span class="c">#NOTE: All is not right in the world. In moving this out of the simulator, to </span>
<span class="c">#      work around an issue with the framework, the use of number_of_nodes for</span>
<span class="c">#      surface simulations was replaced with number_of_vertices, these are not </span>
<span class="c">#      the same thing and doing so has broken the ability to apply stimuli surface </span>
<span class="c">#      simulations that include non-cortical regions in the connectivity </span>
<span class="c">#      matrix. One possible solution would be to create a Structure datatype</span>
<span class="c">#      that merges Cortex and Connectivity before they enter the Simulator,</span>
<span class="c">#      so that a correct number_of_nodes can be accesible before entry to the simulator...</span>
<span class="c">#            if isinstance(self.stimulus, patterns_dtype.StimuliSurface):</span>
<span class="c">#                dis_shp = (self.number_of_nodes,</span>
<span class="c">#                           numpy.size(self.stimulus.focal_points_surface))</span>
<span class="c">#                distance = numpy.zeros(dis_shp)</span>
<span class="c">#                k = -1</span>
<span class="c">#                for focal_point in self.stimulus.focal_points_surface:</span>
<span class="c">#                    k += 1</span>
<span class="c">#                    foci = numpy.array([focal_point], dtype=numpy.int32)</span>
<span class="c">#                    distance[:, k] = self.surface.geodesic_distance(foci)</span>
<span class="c">#            </span>
<span class="c">#            elif isinstance(self.stimulus, patterns_dtype.StimuliRegion):</span>
<span class="c">#                if (self.surface is not None):</span>
<span class="c">#                    #TODO: smooth at surface region boundaries</span>
<span class="c">#                    #import pdb; pdb.set_trace()</span>
<span class="c">#                    distance = self.stimulus.weight_array[self.surface.region_mapping, :]</span>
<span class="c">#                else:</span>
<span class="c">#                    distance = self.stimulus.weight_array</span>
<span class="c">#            </span>
<span class="c">#            LOG.debug(&quot;%s: distance shape is: %s&quot; % (str(self), str(distance.shape)))</span>
<span class="c">#            </span>
<span class="c">#            #Generate spatial pattern using &quot;distance&quot; of all nodes</span>
<span class="c">#            self.stimulus.configure_space(distance)</span>


<div class="viewcode-block" id="Simulator.memory_requirement"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator.memory_requirement">[docs]</a>    <span class="k">def</span> <span class="nf">memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an estimated of the memory requirements (Bytes) for this</span>
<span class="sd">        simulator&#39;s current configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guesstimate_memory_requirement</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_memory_requirement_guess</span>

</div>
<div class="viewcode-block" id="Simulator.runtime"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator.runtime">[docs]</a>    <span class="k">def</span> <span class="nf">runtime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an estimated run time (seconds) for the simulator&#39;s current </span>
<span class="sd">        configuration and a specified simulation length.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulation_length</span> <span class="o">=</span> <span class="n">simulation_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guesstimate_runtime</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_runtime</span>

</div>
<div class="viewcode-block" id="Simulator.storage_requirement"><a class="viewcode-back" href="../../../tvb.simulator.simulator.html#tvb.simulator.simulator.Simulator.storage_requirement">[docs]</a>    <span class="k">def</span> <span class="nf">storage_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an estimated storage requirement (Bytes) for the simulator&#39;s</span>
<span class="sd">        current configuration and a specified simulation length.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulation_length</span> <span class="o">=</span> <span class="n">simulation_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_storage_requirement</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storage_requirement</span>

</div>
    <span class="k">def</span> <span class="nf">_guesstimate_memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Guestimate the memroy required for this simulator.</span>

<span class="sd">        Guesstimate is based on the shape of the dominant arrays, and as such </span>
<span class="sd">        can operate before configuration.</span>

<span class="sd">        NOTE: Assumes returned/yeilded data is in some sense &quot;taken care of&quot; in</span>
<span class="sd">            the world outside the simulator, and so doesn&#39;t consider it, making</span>
<span class="sd">            the simulator&#39;s history, and surface if present, the dominant </span>
<span class="sd">            memory pigs...</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">:</span>
            <span class="n">number_of_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">number_of_vertices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">number_of_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">number_of_regions</span>

        <span class="n">number_of_regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">number_of_regions</span>

        <span class="n">magic_number</span> <span class="o">=</span> <span class="mf">2.42</span> <span class="c"># Current guesstimate is low by about a factor of 2, seems safer to over estimate...</span>
        <span class="n">bits_64</span> <span class="o">=</span> <span class="mf">8.0</span> <span class="c"># Bytes</span>
        <span class="n">bits_32</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="c"># Bytes</span>
        <span class="c">#NOTE: The speed hack for getting the first element of hist shape should</span>
        <span class="c">#      partially resolves calling of this method with a non-configured</span>
        <span class="c">#     connectivity, there remains the less common issue if no tract_lengths...</span>
        <span class="n">hist_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">tract_lengths</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conduction_speed</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="o">.</span><span class="n">speed</span> <span class="ow">or</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="c">#self.connectivity.delays.max() </span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span><span class="p">,</span> <span class="n">number_of_nodes</span><span class="p">,</span> 
                      <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span><span class="p">)</span>
        <span class="n">memreq</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">hist_shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">bits_64</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="p">:</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">number_of_triangles</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">bits_32</span> <span class="o">*</span> <span class="mi">2</span> <span class="c"># normals</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">number_of_vertices</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">bits_64</span> <span class="o">*</span> <span class="mi">2</span> <span class="c"># normals</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="n">number_of_nodes</span> <span class="o">*</span> <span class="n">number_of_regions</span> <span class="o">*</span> <span class="n">bits_64</span> <span class="o">*</span> <span class="mi">4</span> <span class="c">#vertex_mapping, region_average, region_sum</span>
            <span class="c">#???memreq += self.surface.local_connectivity.matrix.nnz * 8</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">monitors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">monitors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitors</span>
        <span class="k">for</span> <span class="n">monitor</span> <span class="ow">in</span> <span class="n">monitors</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span> <span class="n">monitors_module</span><span class="o">.</span><span class="n">Bold</span><span class="p">):</span>
                <span class="n">stock_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">monitor</span><span class="o">.</span><span class="n">period</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> 
                               <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">variables_of_interest</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                               <span class="n">number_of_nodes</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span><span class="p">)</span>
                <span class="n">memreq</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">stock_shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">bits_64</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span> <span class="s">&quot;sensors&quot;</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">memreq</span> <span class="o">+=</span> <span class="n">number_of_nodes</span> <span class="o">*</span> <span class="n">monitor</span><span class="o">.</span><span class="n">sensors</span><span class="o">.</span><span class="n">number_of_sensors</span> <span class="o">*</span> <span class="n">bits_64</span> <span class="c">#projection_matrix</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;No sensors specified, guessing memory based on default EEG.&quot;</span><span class="p">)</span>
                        <span class="n">memreq</span> <span class="o">+=</span> <span class="n">number_of_nodes</span> <span class="o">*</span> <span class="mf">62.0</span> <span class="o">*</span> <span class="n">bits_64</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">stock_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">monitor</span><span class="o">.</span><span class="n">hrf_length</span> <span class="o">*</span> <span class="n">monitor</span><span class="o">.</span><span class="n">_stock_sample_rate</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">variables_of_interest</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">number_of_nodes</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span><span class="p">)</span>
                <span class="n">interim_stock_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">**-</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">),</span> 
                                       <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">variables_of_interest</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                       <span class="n">number_of_nodes</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span><span class="p">)</span>
                <span class="n">memreq</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">stock_shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">bits_64</span>
                <span class="n">memreq</span> <span class="o">+=</span>  <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">interim_stock_shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">bits_64</span>

        <span class="c">#available_memory = 25769803776 #TODO: (this is for my machine)</span>
        <span class="k">if</span> <span class="n">psutil</span> <span class="ow">and</span> <span class="n">memreq</span> <span class="o">&gt;</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()</span><span class="o">.</span><span class="n">total</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;This is gonna get ugly...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_requirement_guess</span> <span class="o">=</span> <span class="n">magic_number</span> <span class="o">*</span> <span class="n">memreq</span>
        <span class="c">#import pdb; pdb.set_trace()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Memory requirement guesstimate: simulation will need about </span><span class="si">%.1f</span><span class="s"> MB&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_requirement_guess</span> <span class="o">/</span> <span class="mf">1048576.0</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_census_memory_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Guesstimate the memory required for this simulator. </span>

<span class="sd">        Guesstimate is based on a census of the dominant arrays after the</span>
<span class="sd">        simulator has been configured.</span>

<span class="sd">        NOTE: Assumes returned/yeilded data is in some sense &quot;taken care of&quot; in</span>
<span class="sd">            the world outside the simulator, and so doesn&#39;t consider it, making</span>
<span class="sd">            the simulator&#39;s history, and surface if present, the dominant </span>
<span class="sd">            memory pigs...</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">magic_number</span> <span class="o">=</span> <span class="mf">2.42</span> <span class="c"># Current guesstimate is low by about a factor of 2, seems safer to over estimate...</span>
        <span class="c">#magic_number = 8.0 # Bytes</span>
        <span class="n">memreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="c">#LOG.info(&quot;Memory required by this simulatin will be approximately %s Bytes&quot; % (memreq))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">triangles</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">*</span> <span class="mi">2</span> <span class="c"># normals</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">*</span> <span class="mi">2</span> <span class="c"># normals</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">vertex_mapping</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">*</span> <span class="mi">4</span> <span class="c">#vertex_mapping, region_average, region_sum</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">eeg_projection</span><span class="o">.</span><span class="n">nbytes</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">local_connectivity</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">nnz</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">for</span> <span class="n">monitor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">:</span>
            <span class="n">memreq</span> <span class="o">+=</span> <span class="n">monitor</span><span class="o">.</span><span class="n">_stock</span><span class="o">.</span><span class="n">nbytes</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monitor</span><span class="p">,</span> <span class="n">monitors_module</span><span class="o">.</span><span class="n">Bold</span><span class="p">):</span>
                <span class="n">memreq</span> <span class="o">+=</span> <span class="n">monitor</span><span class="o">.</span><span class="n">_interim_stock</span><span class="o">.</span><span class="n">nbytes</span>

        <span class="k">if</span> <span class="n">psutil</span> <span class="ow">and</span> <span class="n">memreq</span> <span class="o">&gt;</span> <span class="n">psutil</span><span class="o">.</span><span class="n">virtual_memory</span><span class="p">()</span><span class="o">.</span><span class="n">total</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;This is gonna get ugly...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_memory_requirement_census</span> <span class="o">=</span> <span class="n">magic_number</span> <span class="o">*</span> <span class="n">memreq</span>
        <span class="c">#import pdb; pdb.set_trace()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Memory requirement census: simulation will need about </span><span class="si">%.1f</span><span class="s"> MB&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_memory_requirement_census</span> <span class="o">/</span> <span class="mf">1048576.0</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_guesstimate_runtime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the runtime for this simulator.</span>

<span class="sd">        Spread in parallel executions of larger arrays means this will be an over-estimation,</span>
<span class="sd">        or rather a single threaded estimation...</span>
<span class="sd">        Different choice of integrators and monitors has an additional effect,</span>
<span class="sd">        on the magic number though relatively minor</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">magic_number</span> <span class="o">=</span> <span class="mf">6.57e-06</span>  <span class="c"># seconds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_runtime</span> <span class="o">=</span> <span class="p">(</span><span class="n">magic_number</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span> <span class="o">*</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">simulation_length</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Simulation single-threaded runtime should be about </span><span class="si">%s</span><span class="s"> seconds!&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_runtime</span><span class="p">)))</span>


    <span class="k">def</span> <span class="nf">_calculate_storage_requirement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the storage requirement for the simulator, configured with</span>
<span class="sd">        models, monitors, etc being run for a particular simulation length. </span>
<span class="sd">        While this is only approximate, it is far more reliable/accurate than</span>
<span class="sd">        the memory and runtime guesstimates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Calculating storage requirement for ...&quot;</span><span class="p">)</span>
        <span class="n">strgreq</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">monitor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitors</span><span class="p">:</span>
            <span class="n">strgreq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">TVBSettings</span><span class="o">.</span><span class="n">MAGIC_NUMBER</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_length</span>  <span class="o">*</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nvar</span> <span class="o">*</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">number_of_modes</span> <span class="o">/</span> <span class="n">monitor</span><span class="o">.</span><span class="n">period</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_storage_requirement</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">strgreq</span><span class="p">)</span>


<span class="c">#EoF</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/evil_tvb_logo_transparent.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">The Virtual Brain 1.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>